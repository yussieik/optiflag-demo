<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OptiFlag - Advanced Trading Pattern Recognition System</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/styles.css">
    <script>
    // Make navigateToResults globally accessible
    function navigateToResults() {
        document.getElementById('intro-container').classList.add('fade-out');
        setTimeout(() => {
            window.location.href = 'main.html';
        }, 500);
    }
    
    // Optimization simulation logic
    window.onload = function() {
        const experiments = [{ticker: 'TSLA',name: 'bayes_iter_49',score: 54.55,winRate: 54.5,rank: 1},{ticker: 'TSLA',name: 'bayes_iter_50',score: 54.55,winRate: 54.5,rank: 2},{ticker: 'TSLA',name: 'bayes_iter_33',score: 45.83,winRate: 45.8,rank: 3},{ticker: 'TSLA',name: 'bayes_iter_40',score: 45.83,winRate: 45.8,rank: 4},{ticker: 'TSLA',name: 'bayes_iter_45',score: 45.83,winRate: 45.8,rank: 5}];
        
        const steps = [
            { text: "Initializing Bayesian Optimizer...", progress: 10 },
            { text: "Loading market data...", progress: 20 },
            { text: "Detecting flagpole patterns...", progress: 35 },
            { text: "Running optimization generation 1...", progress: 45, showExperiment: 0 },
            { text: "Evaluating fitness scores...", progress: 55, showExperiment: 1 },
            { text: "Running optimization generation 5...", progress: 65, showExperiment: 2 },
            { text: "Convergence detected...", progress: 80, showExperiment: 3 },
            { text: "Validating on forward test data...", progress: 90, showExperiment: 4 },
            { text: "Optimization complete!", progress: 100 }
        ];
        
        let currentStep = 0;
        const statusText = document.getElementById('status-text');
        const progressBar = document.getElementById('progress-fill');
        const metricsContainer = document.getElementById('metrics-container');
        const patternViz = document.getElementById('pattern-viz');
        const experimentList = document.getElementById('experiment-list');
        const experimentsDiscovered = document.getElementById('experiments-discovered');
        
        // Initialize stock market optimization visualization
        function initializeStockOptimizationViz() {
            const canvas = document.createElement('canvas');
            canvas.id = 'optimization-canvas';
            canvas.width = patternViz.offsetWidth || 800;
            canvas.height = 200;
            patternViz.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            return { canvas, ctx };
        }
        
        const vizContext = initializeStockOptimizationViz();
        let stockPriceData = [];
        let candidatePoints = [];
        let currentBestMinima = null;
        let explorationProbes = [];
        
        // Generate realistic stock price data with volatility
        function generateStockData() {
            stockPriceData = [];
            let price = 100;
            let trend = 0;
            
            for (let i = 0; i < 200; i++) {
                // Add trend changes at certain points
                if (i === 40) trend = -0.3;  // Downtrend
                if (i === 80) trend = 0.1;   // Slight uptrend
                if (i === 120) trend = -0.5; // Sharp downtrend
                if (i === 160) trend = 0.2;  // Recovery
                
                // Random walk with trend
                const randomWalk = (Math.random() - 0.5) * 2;
                price += trend + randomWalk;
                
                // Add some volatility spikes
                if (Math.random() < 0.1) {
                    price += (Math.random() - 0.5) * 5;
                }
                
                stockPriceData.push({
                    x: i,
                    price: price,
                    normalized: price // Will be normalized later
                });
            }
            
            // Normalize prices to fit canvas
            const minPrice = Math.min(...stockPriceData.map(d => d.price));
            const maxPrice = Math.max(...stockPriceData.map(d => d.price));
            const priceRange = maxPrice - minPrice;
            
            stockPriceData.forEach(point => {
                point.normalized = 180 - ((point.price - minPrice) / priceRange) * 160 + 10;
            });
        }
        
        generateStockData();
        
        // Draw stock market data and optimization process
        function drawStockOptimization(ctx, canvas, progress) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dark background
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, 'rgba(11, 20, 38, 0.95)');
            bgGradient.addColorStop(1, 'rgba(30, 41, 59, 0.95)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (canvas.height / 10) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw stock price line
            ctx.strokeStyle = 'rgba(100, 116, 139, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const xScale = canvas.width / stockPriceData.length;
            stockPriceData.forEach((point, i) => {
                const x = point.x * xScale;
                const y = point.normalized;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Highlight explored regions with heat map effect
            candidatePoints.forEach(candidate => {
                const x = candidate.x * xScale;
                const gradient = ctx.createRadialGradient(x, candidate.y, 0, x, candidate.y, 30);
                
                if (candidate.isMinima) {
                    // Green glow for detected minima
                    gradient.addColorStop(0, 'rgba(0, 212, 163, 0.3)');
                    gradient.addColorStop(1, 'rgba(0, 212, 163, 0)');
                } else {
                    // Blue glow for exploration
                    gradient.addColorStop(0, 'rgba(14, 165, 233, 0.2)');
                    gradient.addColorStop(1, 'rgba(14, 165, 233, 0)');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x - 30, 0, 60, canvas.height);
            });
            
            // Draw exploration probes (Bayesian acquisition function visualization)
            ctx.strokeStyle = 'rgba(14, 165, 233, 0.6)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            
            explorationProbes.forEach(probe => {
                const x = probe.x * xScale;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                
                // Draw acquisition function value
                const acquisitionHeight = probe.acquisition * 50;
                ctx.fillStyle = 'rgba(14, 165, 233, 0.3)';
                ctx.fillRect(x - 2, canvas.height - acquisitionHeight, 4, acquisitionHeight);
            });
            ctx.setLineDash([]);
            
            // Draw detected minima
            candidatePoints.filter(c => c.isMinima).forEach(minima => {
                const x = minima.x * xScale;
                
                // Draw vertical line
                ctx.strokeStyle = 'rgba(0, 212, 163, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, minima.y - 20);
                ctx.lineTo(x, minima.y + 20);
                ctx.stroke();
                
                // Draw circle at minima
                ctx.beginPath();
                ctx.arc(x, minima.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#00D4A3';
                ctx.fill();
                ctx.strokeStyle = '#0B1426';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Pulsing effect
                const pulseSize = 8 + Math.sin(Date.now() / 200) * 3;
                ctx.beginPath();
                ctx.arc(x, minima.y, pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 212, 163, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
            
            // Draw current best minima if found
            if (currentBestMinima) {
                const x = currentBestMinima.x * xScale;
                
                // Highlight box
                ctx.fillStyle = 'rgba(0, 212, 163, 0.1)';
                ctx.fillRect(x - 20, 0, 40, canvas.height);
                
                // Label
                ctx.fillStyle = '#00D4A3';
                ctx.font = '11px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('OPTIMAL', x, currentBestMinima.y - 15);
            }
            
            // Draw legend
            ctx.font = '10px Inter';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillText('Price History', 10, 20);
            
            ctx.fillStyle = 'rgba(14, 165, 233, 0.8)';
            ctx.fillText('• Exploration', 10, 35);
            
            ctx.fillStyle = 'rgba(0, 212, 163, 0.8)';
            ctx.fillText('• Local Minima', 10, 50);
        }
        
        // Update optimization based on progress
        function updateStockOptimization(progress) {
            const dataIndex = Math.floor((progress / 100) * stockPriceData.length);
            
            // Simulate Bayesian optimization exploration
            if (progress > 10 && Math.random() < 0.3) {
                // Add exploration probe
                const probeIndex = Math.floor(Math.random() * dataIndex);
                explorationProbes.push({
                    x: probeIndex,
                    acquisition: Math.random()
                });
                
                // Keep only recent probes
                if (explorationProbes.length > 10) {
                    explorationProbes.shift();
                }
            }
            
            // Detect local minima in explored region
            if (progress > 20 && Math.random() < 0.2) {
                const checkIndex = Math.floor(Math.random() * dataIndex);
                const point = stockPriceData[checkIndex];
                
                // Check if it's a local minimum (simplified)
                const isLocalMin = checkIndex > 5 && checkIndex < stockPriceData.length - 5 &&
                    stockPriceData.slice(checkIndex - 5, checkIndex + 5)
                        .every(p => p.price >= point.price - 0.5);
                
                if (isLocalMin || Math.random() < 0.1) {
                    const candidate = {
                        x: checkIndex,
                        y: point.normalized,
                        price: point.price,
                        isMinima: isLocalMin
                    };
                    
                    candidatePoints.push(candidate);
                    
                    // Update best minima
                    if (isLocalMin && (!currentBestMinima || point.price < currentBestMinima.price)) {
                        currentBestMinima = candidate;
                    }
                }
            }
            
            // Keep reasonable number of candidates
            if (candidatePoints.length > 15) {
                candidatePoints = candidatePoints.slice(-15);
            }
        }
        
        // Add particle effects
        function createParticles() {
            const container = document.getElementById('intro-container');
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 5 + 's';
                particle.style.animationDuration = (5 + Math.random() * 5) + 's';
                container.appendChild(particle);
            }
        }
        createParticles();
        
        // Animate optimization process
        function animateStep() {
            if (currentStep < steps.length) {
                const step = steps[currentStep];
                statusText.textContent = step.text;
                progressBar.style.width = step.progress + '%';
                
                // Update metrics randomly during optimization
                if (currentStep > 2 && currentStep < steps.length - 1) {
                    updateMetrics();
                }
                
                // Show experiment if this step reveals one
                if (step.showExperiment !== undefined && experiments[step.showExperiment]) {
                    showExperiment(experiments[step.showExperiment]);
                }
                
                // Update stock optimization visualization
                updateStockOptimization(step.progress);
                drawStockOptimization(vizContext.ctx, vizContext.canvas, step.progress);
                
                currentStep++;
                setTimeout(animateStep, 600);
            } else {
                // Show final metrics
                showFinalMetrics();
                // Show the completion button after a brief pause
                setTimeout(() => {
                    showCompletionButton();
                }, 1000);
            }
        }
        
        function updateMetrics() {
            const patterns = Math.floor(Math.random() * 50) + 100;
            const score = (Math.random() * 0.3 + 0.7).toFixed(3);
            const winRate = (Math.random() * 20 + 60).toFixed(1);
            
            document.getElementById('patterns-found').textContent = patterns;
            document.getElementById('optimization-score').textContent = score;
            document.getElementById('win-rate').textContent = winRate + '%';
        }
        
        function showFinalMetrics() {
            // Calculate totals from actual experiments
            const totalPatterns = experiments.length * 30; // Approximate
            const avgScore = experiments.reduce((sum, exp) => sum + exp.score, 0) / experiments.length;
            const avgWinRate = experiments.reduce((sum, exp) => sum + exp.winRate, 0) / experiments.length;
            
            document.getElementById('patterns-found').textContent = totalPatterns;
            document.getElementById('optimization-score').textContent = avgScore.toFixed(3);
            document.getElementById('win-rate').textContent = avgWinRate.toFixed(1) + '%';
            metricsContainer.classList.add('highlight-final');
        }
        
        function showCompletionButton() {
            const buttonContainer = document.getElementById('completion-button-container');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.opacity = '0';
            
            // Fade in the button
            setTimeout(() => {
                buttonContainer.style.opacity = '1';
            }, 50);
        }
        
        function showExperiment(experiment) {
            experimentsDiscovered.style.display = 'block';
            
            const expDiv = document.createElement('div');
            expDiv.className = 'experiment-item';
            expDiv.innerHTML = `
                <div class="experiment-rank">#${experiment.rank}</div>
                <div class="experiment-details">
                    <div class="experiment-ticker">${experiment.ticker}</div>
                    <div class="experiment-name">${experiment.name}</div>
                </div>
                <div class="experiment-metrics">
                    <span class="experiment-score">Score: ${experiment.score.toFixed(2)}</span>
                    <span class="experiment-winrate">Win: ${experiment.winRate.toFixed(1)}%</span>
                </div>
            `;
            
            // Add stagger delay based on how many experiments are already shown
            const existingExperiments = experimentList.querySelectorAll('.experiment-item').length;
            expDiv.style.animationDelay = `${existingExperiments * 0.1}s`;
            
            experimentList.appendChild(expDiv);
        }
        
        // Continuous animation loop for the visualization
        function animateVisualization() {
            if (vizContext && vizContext.ctx && vizContext.canvas) {
                drawStockOptimization(vizContext.ctx, vizContext.canvas, (currentStep / steps.length) * 100);
                requestAnimationFrame(animateVisualization);
            }
        }
        
        // Start animations
        setTimeout(animateStep, 500);
        animateVisualization();
    };
    </script>
</head>
<body class="intro-body">
    <div id="intro-container" class="intro-container">
        <div class="intro-header">
            <h1 class="intro-title">OptiFlag</h1>
            <p class="intro-subtitle">Advanced Trading Pattern Recognition System</p>
        </div>
        
        <div class="optimization-container">
            <div class="optimization-header">
                <h2>Running Bayesian Optimization</h2>
                <div class="ticker-badge">TSLA</div>
            </div>
            
            <div class="pattern-visualization" id="pattern-viz">
                <div class="viz-title">Bayesian Search for Market Minima</div>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <p id="status-text" class="status-text">Initializing...</p>
            </div>
            
            <div id="metrics-container" class="metrics-grid intro-metrics">
                <div class="metric-box">
                    <span class="metric-label">Patterns Found</span>
                    <span id="patterns-found" class="metric-value">0</span>
                </div>
                <div class="metric-box">
                    <span class="metric-label">Optimization Score</span>
                    <span id="optimization-score" class="metric-value">0.000</span>
                </div>
                <div class="metric-box">
                    <span class="metric-label">Win Rate</span>
                    <span id="win-rate" class="metric-value">0.0%</span>
                </div>
            </div>
            
            <div id="experiments-discovered" class="experiments-discovered">
                <h3>Top Experiments Discovered</h3>
                <div id="experiment-list" class="experiment-list"></div>
            </div>
            
            <div class="discovery-note">
                <p>Discovering optimal trading parameters through Bayesian optimization...</p>
            </div>
            
            <div id="completion-button-container" class="completion-button-container">
                <button onclick="navigateToResults()" class="view-results-btn">
                    View Full Results
                    <span class="btn-arrow">→</span>
                </button>
                <p class="completion-message">Optimization complete! Click to explore detailed analysis.</p>
            </div>
        </div>
    </div>
</body>
</html>