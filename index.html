<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OptiFlag - Advanced Trading Pattern Recognition System</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/styles.css">
    <script>
    // Make navigateToResults globally accessible
    function navigateToResults() {
        document.getElementById('intro-container').classList.add('fade-out');
        setTimeout(() => {
            window.location.href = 'main.html';
        }, 500);
    }
    
    // Optimization simulation logic
    window.onload = function() {
        const experiments = [{ticker: 'TSLA',name: 'bayes_iter_49',score: 54.55,winRate: 54.5,rank: 1},{ticker: 'TSLA',name: 'bayes_iter_50',score: 54.55,winRate: 54.5,rank: 2},{ticker: 'TSLA',name: 'bayes_iter_33',score: 45.83,winRate: 45.8,rank: 3},{ticker: 'TSLA',name: 'bayes_iter_40',score: 45.83,winRate: 45.8,rank: 4},{ticker: 'TSLA',name: 'bayes_iter_45',score: 45.83,winRate: 45.8,rank: 5}];
        
        const steps = [
            { text: "Initializing Bayesian Optimizer...", progress: 10 },
            { text: "Loading market data...", progress: 20 },
            { text: "Detecting flagpole patterns...", progress: 35 },
            { text: "Running optimization generation 1...", progress: 45, showExperiment: 0 },
            { text: "Evaluating fitness scores...", progress: 55, showExperiment: 1 },
            { text: "Running optimization generation 5...", progress: 65, showExperiment: 2 },
            { text: "Convergence detected...", progress: 80, showExperiment: 3 },
            { text: "Validating on forward test data...", progress: 90, showExperiment: 4 },
            { text: "Optimization complete!", progress: 100 }
        ];
        
        let currentStep = 0;
        const statusText = document.getElementById('status-text');
        const progressBar = document.getElementById('progress-fill');
        const metricsContainer = document.getElementById('metrics-container');
        const patternViz = document.getElementById('pattern-viz');
        const experimentList = document.getElementById('experiment-list');
        const experimentsDiscovered = document.getElementById('experiments-discovered');
        
        // Initialize optimization landscape visualization
        function initializeOptimizationViz() {
            const canvas = document.createElement('canvas');
            canvas.id = 'optimization-canvas';
            canvas.width = patternViz.offsetWidth || 800;
            canvas.height = 200;
            patternViz.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            
            // Create gradient background
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, 'rgba(0, 212, 163, 0.05)');
            bgGradient.addColorStop(1, 'rgba(14, 165, 233, 0.05)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            return { canvas, ctx };
        }
        
        const vizContext = initializeOptimizationViz();
        let optimizationPath = [];
        let particles = [];
        
        // Create optimization landscape with peaks and valleys
        function drawOptimizationLandscape(ctx, canvas, progress) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, 'rgba(0, 212, 163, 0.05)');
            bgGradient.addColorStop(1, 'rgba(14, 165, 233, 0.05)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 10; i++) {
                const x = (canvas.width / 10) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Draw optimization function landscape
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            
            const points = 100;
            for (let i = 0; i <= points; i++) {
                const x = (canvas.width / points) * i;
                const baseY = canvas.height / 2;
                
                // Create multiple peaks representing local optima
                const peak1 = 30 * Math.exp(-Math.pow((i - 20) / 10, 2));
                const peak2 = 50 * Math.exp(-Math.pow((i - 50) / 15, 2));
                const peak3 = 70 * Math.exp(-Math.pow((i - 80) / 12, 2)); // Global optimum
                
                const y = baseY - peak1 - peak2 - peak3 + 10 * Math.sin(i / 5);
                ctx.lineTo(x, y);
            }
            
            // Fill under the curve
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(0, 212, 163, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 212, 163, 0.02)');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw the optimization path
            if (optimizationPath.length > 1) {
                ctx.strokeStyle = '#00D4A3';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00D4A3';
                
                ctx.beginPath();
                ctx.moveTo(optimizationPath[0].x, optimizationPath[0].y);
                
                for (let i = 1; i < optimizationPath.length; i++) {
                    const point = optimizationPath[i];
                    ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();
                
                // Draw current position
                const currentPoint = optimizationPath[optimizationPath.length - 1];
                ctx.beginPath();
                ctx.arc(currentPoint.x, currentPoint.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#00D4A3';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.shadowBlur = 0;
            }
            
            // Draw exploring particles
            particles.forEach(particle => {
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 212, 163, ${particle.opacity})`;
                ctx.fill();
                
                // Update particle position
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.opacity *= 0.98;
                particle.size *= 0.99;
            });
            
            // Remove faded particles
            particles = particles.filter(p => p.opacity > 0.01);
            
            // Add new particles occasionally
            if (Math.random() < 0.3 && particles.length < 20) {
                const currentPoint = optimizationPath[optimizationPath.length - 1] || { x: 0, y: canvas.height / 2 };
                particles.push({
                    x: currentPoint.x,
                    y: currentPoint.y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: Math.random() * 3 + 1,
                    opacity: 0.6
                });
            }
        }
        
        // Update optimization path based on progress
        function updateOptimizationPath(progress) {
            const canvas = vizContext.canvas;
            const x = (canvas.width / 100) * progress;
            
            // Calculate y position on the landscape
            const baseY = canvas.height / 2;
            const i = progress;
            const peak1 = 30 * Math.exp(-Math.pow((i - 20) / 10, 2));
            const peak2 = 50 * Math.exp(-Math.pow((i - 50) / 15, 2));
            const peak3 = 70 * Math.exp(-Math.pow((i - 80) / 12, 2));
            const y = baseY - peak1 - peak2 - peak3 + 10 * Math.sin(i / 5);
            
            optimizationPath.push({ x, y });
            
            // Keep only recent points for performance
            if (optimizationPath.length > 100) {
                optimizationPath.shift();
            }
        }
        
        // Add particle effects
        function createParticles() {
            const container = document.getElementById('intro-container');
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 5 + 's';
                particle.style.animationDuration = (5 + Math.random() * 5) + 's';
                container.appendChild(particle);
            }
        }
        createParticles();
        
        // Animate optimization process
        function animateStep() {
            if (currentStep < steps.length) {
                const step = steps[currentStep];
                statusText.textContent = step.text;
                progressBar.style.width = step.progress + '%';
                
                // Update metrics randomly during optimization
                if (currentStep > 2 && currentStep < steps.length - 1) {
                    updateMetrics();
                }
                
                // Show experiment if this step reveals one
                if (step.showExperiment !== undefined && experiments[step.showExperiment]) {
                    showExperiment(experiments[step.showExperiment]);
                }
                
                // Update optimization visualization
                updateOptimizationPath(step.progress);
                drawOptimizationLandscape(vizContext.ctx, vizContext.canvas, step.progress);
                
                currentStep++;
                setTimeout(animateStep, 600);
            } else {
                // Show final metrics
                showFinalMetrics();
                // Show the completion button after a brief pause
                setTimeout(() => {
                    showCompletionButton();
                }, 1000);
            }
        }
        
        function updateMetrics() {
            const patterns = Math.floor(Math.random() * 50) + 100;
            const score = (Math.random() * 0.3 + 0.7).toFixed(3);
            const winRate = (Math.random() * 20 + 60).toFixed(1);
            
            document.getElementById('patterns-found').textContent = patterns;
            document.getElementById('optimization-score').textContent = score;
            document.getElementById('win-rate').textContent = winRate + '%';
        }
        
        function showFinalMetrics() {
            // Calculate totals from actual experiments
            const totalPatterns = experiments.length * 30; // Approximate
            const avgScore = experiments.reduce((sum, exp) => sum + exp.score, 0) / experiments.length;
            const avgWinRate = experiments.reduce((sum, exp) => sum + exp.winRate, 0) / experiments.length;
            
            document.getElementById('patterns-found').textContent = totalPatterns;
            document.getElementById('optimization-score').textContent = avgScore.toFixed(3);
            document.getElementById('win-rate').textContent = avgWinRate.toFixed(1) + '%';
            metricsContainer.classList.add('highlight-final');
        }
        
        function showCompletionButton() {
            const buttonContainer = document.getElementById('completion-button-container');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.opacity = '0';
            
            // Fade in the button
            setTimeout(() => {
                buttonContainer.style.opacity = '1';
            }, 50);
        }
        
        function showExperiment(experiment) {
            experimentsDiscovered.style.display = 'block';
            
            const expDiv = document.createElement('div');
            expDiv.className = 'experiment-item';
            expDiv.innerHTML = `
                <div class="experiment-rank">#${experiment.rank}</div>
                <div class="experiment-details">
                    <div class="experiment-ticker">${experiment.ticker}</div>
                    <div class="experiment-name">${experiment.name}</div>
                </div>
                <div class="experiment-metrics">
                    <span class="experiment-score">Score: ${experiment.score.toFixed(2)}</span>
                    <span class="experiment-winrate">Win: ${experiment.winRate.toFixed(1)}%</span>
                </div>
            `;
            
            // Add stagger delay based on how many experiments are already shown
            const existingExperiments = experimentList.querySelectorAll('.experiment-item').length;
            expDiv.style.animationDelay = `${existingExperiments * 0.1}s`;
            
            experimentList.appendChild(expDiv);
        }
        
        // Continuous animation loop for the visualization
        function animateVisualization() {
            if (vizContext && vizContext.ctx && vizContext.canvas) {
                drawOptimizationLandscape(vizContext.ctx, vizContext.canvas, (currentStep / steps.length) * 100);
                requestAnimationFrame(animateVisualization);
            }
        }
        
        // Start animations
        setTimeout(animateStep, 500);
        animateVisualization();
    };
    </script>
</head>
<body class="intro-body">
    <div id="intro-container" class="intro-container">
        <div class="intro-header">
            <h1 class="intro-title">OptiFlag</h1>
            <p class="intro-subtitle">Advanced Trading Pattern Recognition System</p>
        </div>
        
        <div class="optimization-container">
            <div class="optimization-header">
                <h2>Running Bayesian Optimization</h2>
                <div class="ticker-badge">TSLA</div>
            </div>
            
            <div class="pattern-visualization" id="pattern-viz">
                <div class="viz-title">Optimization Landscape Explorer</div>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <p id="status-text" class="status-text">Initializing...</p>
            </div>
            
            <div id="metrics-container" class="metrics-grid intro-metrics">
                <div class="metric-box">
                    <span class="metric-label">Patterns Found</span>
                    <span id="patterns-found" class="metric-value">0</span>
                </div>
                <div class="metric-box">
                    <span class="metric-label">Optimization Score</span>
                    <span id="optimization-score" class="metric-value">0.000</span>
                </div>
                <div class="metric-box">
                    <span class="metric-label">Win Rate</span>
                    <span id="win-rate" class="metric-value">0.0%</span>
                </div>
            </div>
            
            <div id="experiments-discovered" class="experiments-discovered">
                <h3>Top Experiments Discovered</h3>
                <div id="experiment-list" class="experiment-list"></div>
            </div>
            
            <div class="discovery-note">
                <p>Discovering optimal trading parameters through Bayesian optimization...</p>
            </div>
            
            <div id="completion-button-container" class="completion-button-container">
                <button onclick="navigateToResults()" class="view-results-btn">
                    View Full Results
                    <span class="btn-arrow">→</span>
                </button>
                <p class="completion-message">Optimization complete! Click to explore detailed analysis.</p>
            </div>
        </div>
    </div>
</body>
</html>